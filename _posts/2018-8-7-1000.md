---
layout: default
title: 1000
---

### <h2>HDU OJ 1000 </h2>

今天的内容很简单，是求两个数的和。输入的两个数由空格隔开，如【NUM1 NUM2】这样。

普通的求和应该很方便，但是害怕溢出的情况。所以我做了一个大数求和。那么问题来了。

- 如何读取长度未知的两个由空格隔开的大数？

  	我的第一个尝试：

```c++
uint8_t adder1[512] = { 0 };
short int index=0;
while (scanf("%1hhd", &adder1[index++]))；//读取直到非数字
```

​	但是很遗憾，这个尝试失败。格式化输入的格式中，空格必须显示地作为分隔符才行。

​	这里我处理得不是很好。只是傻乎乎地采取了getchar的方式，每次读取后都要判断是否是空格或者换行符。

```
	while (true)
	{
		adder1[length1] = getchar() - 48;
		if (adder1[length1] == 240 || length1 == 511) //240 + 48 == ' '
		{
			adder1[length1] = 0;	//剔除不良影响
			break;
		}
		length1++;
	}
```

​	这样很笨拙。但勉强能用。

- 进位、存储和输出

  输入时就要考虑进位的那个最高位保留（不能输入512位整数，以防止溢出）。输出的时候要从高位输出。

  进位就是采取手算的方式，有可能会产生冗余计算。

一言以蔽之，并不是什么好程序。

**而且重点是！提交之后是WRONG ERROR！**

= =心塞。而我没有看到这个产生 wrong error的case= =我好傻。

后来仔细读题，大家说HDU OJ对输入输出特别严格。然后页面上写了要处理EOF……是的我完全跑偏了……这个题目的坑不在于溢出和大数，而在于读取时候对EOF的处理……

ACCEPT版本代码：

<strong>不知道为什么这个的内存占用率为1798K，分明只有两个int变量……</strong>

<strong>这里利用scanf的返回值，又可以了……噢，因为是EOF的缘故吗（EOF == 0） </strong>

```
#include <stdio.h>
int main(void)
{
	int a, b;
	while (scanf("%d%d", &a, &b) != EOF)
		printf("%d\n", a + b);
	return 0;
}
```



wrong answer版本：

```
#include <cstdio>
#include <cstdint>


int main()
{
	uint8_t adder1[512] = { 0 };
	uint8_t adder2[512] = { 0 };
	short int length1 =0, length2 = 0;
	
	while (true)
	{
		adder1[length1] = getchar() - 48;
		if (adder1[length1] == 240 || length1 == 511)   //240 + 48 ' '
		{
			adder1[length1] = 0;
			break;
		}
		length1++;
	}

	while (true)
	{
		adder2[length2] = getchar() - 48;
		if (adder2[length2] == 218 || length2 == 510 )  //218+48 '/n'
		{
			adder2[length2] = 0;
			break;
		}
		length2++;
	}

	length1 = (length1 > length2 ? length1 : length2) - 2;

	for (int i = 0; i < length1; i++)
	{
		uint8_t tmp = (adder1[i] + adder2[i]) % 10; //如果是2的幂次方，可以使用逻辑与来进行清零和保留
		adder1[i+1] += (adder1[i] + adder2[i]) / 10;
		adder1[i] = tmp;
	}

	if (adder1[length1 + 1] != 0)
		printf("%1d", adder1[length1 + 1]);
	while (length1>=0)
	{
		printf("%1d", adder1[length1--]);
	}
	printf("\n");
	return 0;
}
```



调试的时候，遭遇了【调试进程GUI已经关闭，但进程并未关闭】的情况。不知道是不是因为我调试的时候，代码更改后用ctrl+shift+F5重新调试引起（VS2015没有释放先前的进程），导致后来就无法编译调试（无法访问可执行文件exe）。

更让人崩溃的是，进程被拒绝访问，无法关闭进程数和终止。

不得不关闭VS2015这个主进程来关掉整个进程数。

同时学习到了一个新的dos命令：

```bash
taskkill /f /t /pid PIDNUMBER
#/f 表示强制关闭，/t 表示关闭进程数， /pid 表示关闭pid为PIDNUMBER的进程。其中/pid 参数还有更加灵活的用法，比如关闭PID小于PIDNUMBER的进程等等。参考帮助文档 taskkill /?
```



今天的内容，潦草结束了。



<p> {{page.date | date_to_string}} </p>