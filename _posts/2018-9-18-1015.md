---
title: 1015
description: HDU OJ 1015 Safecracker
categories:
- HDU
tags:
- HDU
---

### HDU OJ 1015 -- Safecracker

#### 题目分析

首先感谢klein，要不是他有个保险箱，可能没有这道题（I'm joking 23333）。

---

​	一开始我只是暴力求解（当然不是五重循环了），就是用一个五元数组遍历可能出现的情况，模拟进制进位的方式。总共的计算次数为：

​	A_{length}^{5} = length^{5}      （length是输入的字符串长度）。

​	然后发现似乎不允许有相同字符作为答案。因此其实这里面有很多重复计算。数据量可以减少到：

​	C_{length}^{5}

​	好吧，没什么用。= = 因为写起来有点麻烦。我出错了。

​	我搞错了一个问题，字母所代表的值是字母序，而不是输入序列的index。比如A=1，不会因为输入时候A的位置而改变。

---

##### 抽象起来！！！

---

​	我在调试的过程之中，遭遇了一个问题。在VS2017之中，for循环的自动补全中，循环变量的类型是**size_t类型**，其实就是**unsigned int类型**。

​	而我在这个for循环中使用了递减……然后满心以为i=0时 i-- 应该是-1，但因为unsigned int类型而导致出错。不仅循环没有结束，而且因为循环变量的访问都越界而中断了！

----

##### 抽象过程！抽象代码！抽象问题！！

一次AC，开心。

#### AC代码

```c++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;
using std::string;
using std::vector;

int numbers[5];
int target;
int visit[27];
vector<int> valueset;
vector<int> result;
bool isfinish;

void getValueAndInit(string strn)
{
	valueset.clear();
	result.clear();
	memset(visit, 0, sizeof(int) * 27);
	isfinish = false;
	for (size_t i = 0; i < strn.size(); i++)
	{
		valueset.push_back(strn[i] - 64);
	}
	sort(valueset.begin(), valueset.end());
}
int compute()
{
	if ((numbers[0] - numbers[1] * numbers[1] + numbers[2] * numbers[2] * numbers[2] - numbers[3] * numbers[3] * numbers[3] * numbers[3] + numbers[4] * numbers[4] * numbers[4] * numbers[4] * numbers[4]) == target)
		return 1;
	return 0;
}
void choose(int size, int index)
{
		for (int i = size-1; i >=0; i--)
		{
			if (visit[valueset[i]] != true)
			{
				visit[valueset[i]] = true;
				if (index == 4 )
				{
					numbers[index] = valueset[i];
					if (compute())
					{
						result = (vector<int>(numbers, numbers + 5));
						isfinish = true;
						return;
					}

				}
				else
				{
					numbers[index] = valueset[i];
					choose(size, index + 1);
					if (isfinish == true)
						return;
				}
				visit[valueset[i]] = false;
			}
			else
				continue;
		}

}
int main()
{
	string letterset;
	while (cin >> target >> letterset && target)
	{
		getValueAndInit(letterset);
		choose(letterset.length(), 0);
		if(result.size() == 0)
		{
			cout << "no solution" << endl;
		}
		else
		{
			for (size_t i = 0; i < 5; i++)
			{
				printf("%c", result[i] + 64);
			}
			cout << endl;
		}
	}
    return 0;
}
```

很开心~

数组循环应该也很不错的！总之就是ac了很开心。:happy:

{{page.date | date_to_string}}