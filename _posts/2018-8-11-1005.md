---
layout: default
title: 1005
---

### HDU OJ 1005

题目：计算递推序列的某个值。

f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.

Given A, B, and n, you are to calculate the value of f(n).

input：A,B和N。 (1 <= A, B <= 1000, 1 <= n <= 100,000,000)。三个0表示结束。

out：Fn

----

今天第一次遭遇了不一样的失败CODE： **Time Limit Exceeded**。

本来还在想这个不是很容易的一个递推序列的吗233333。

应该还有别的办法。

- 递推

但是递推不好使。

F(N+1) = AxF(N) + BxF(N-1) mod 7

F(N+1) = (AxF(N-1) + BxF(N-2)) + BxF(N-1) mod 7 = (A+B)xF(N-1)  + BxF(N-2) mod 7

F(N+2) = AxF(N+1)+BxF(N)

​	= Ax(A+B)xF(N-1) + A*BxF(N-2) +  (AxF(N-1) + BxF(N-2)) 

​	=A(1+A+B)xF(N-1) + B(A+1)xF(N-2)

F(N+3) = AxF(N+2) + BxF(N+1)

​	=AxA(1+A+B)F(N-1) + AB(A+1)F(N-2) + B(A+B)xF(N-1) + BBxF(N-2)

直接递推会越来越复杂。

- 周期

同余序列产生周期。

那么如何计算给定AB时候的周期呢？

我一开始想寻找一个二阶同余序列的周期公式。但是没有找到我的笔记本= =

但是可以划一个最大周期范围（感谢模数7比较小）：

> 当A、B输入确定后，变化量来自于 F(n-1)和F(n-2)。而在mod 7的情况下，F(n-1)和F(n-2)的组合对（F(n-1)，F(n-2)）一共有且仅有7x7=49种情况。
>
> (0,0), (0,1) ……(6,5), (6,6)
>
> 虽然在此处很想断言， 周期不会超过49。但是我还是有一点没有想明白。
>
> 对第N拍来说，确实出现的情况只能是49种中的某一种，但是怎么确保周期也要小于49呢？（其中应该和模数7还有初始的(1,1)有关系，但其中的关系还没有被阐明= =）
>
> 但从实验结果来看，确实没有大于49的周期产生。

实验代码：

```C++
for (int A = 1; A < 1000; A++)
	{
		for (int B = 1; B < 1000; B++)
		{
			int FN[128] = { 0,1, 1 };
					for (int i = 3; i < 128; i++)
					{
						FN[i] = (A*FN[i-1] + B * FN[i-2]) % 7;
					}
					for (int i = 3; i < 126; i++)
					{
						
						if (FN[i] == FN[1] && FN[i + 1] == FN[2] && FN[i + 2] == FN[3])
						{
							if(i > 49)
								cout << A << " "<<B <<" " << i << endl;
							break;
						}
					}
		}
```

AC代码：

```C++
#include <iostream>
using namespace std;

int main()
{
	do {
		int A;
		int B;
		int N;
		int FN[55] = { 0,1,1 };

		cin >> A >> B >> N;
		if (A == 0 && B == 0 && N == 0)
			break;
		
		for (int i = 3; i < 50; i++)  //为了避免下标的计算，从1开始计数。
		{
			FN[i] = (A*FN[i-1] + B * FN[i-2]) % 7;
		}
		cout << FN[N%49] << endl;
	} while (true);

    return 0;
}
```



结束。

{{page.date | date_to_string}}



