---
title: 1014
description: HDU OJ 1014 Uniform Generator
categories:
- HDU
tags:
- HDU
---

### HDU OJ 1014 -- Uniform Generator

#### 题目说明

哈哈哈哈，终于有一道题撞到我手里啦。

这个呢，就是同余式的生成群。看这个群的长度能不能达到最大值。

也就是考察 step和mod之间的关系！

>**费马小定理**（Fermat Theory）是数论中的一个重要**定理**，其内容为： 假如p是质数，且Gcd(a,p)=1，那么a(p-1)≡1（mod p）。 即：假如a是整数，p是质数，且a,p互质(即两者只有一个公约数1)，那么a的(p-1)次方除以p的余数恒等于1。
>
>欧拉定理（也称费马-欧拉定理或欧拉 函数定理）是一个关于同余的性质。
>
>欧拉定理实际上是费马小定理的推广。

也就是说，只要step和mod互素，那么就可以产生最大长度的群。因为此时step在mod下有逆元。

#### AC代码

```c++
#include <iostream>
using namespace std;

bool gcd(int s, int p)
{
	int bigger, smaller, rest;
	bigger = s > p ? s : p;
	smaller = bigger ^ p^s;
	
	do
	{
		rest = bigger % smaller;
		bigger = smaller;
		smaller = rest;
	} while (rest !=0);

	if (bigger == 1)
		return true;
	else
		return false;
}

/*
int gcd(int s, int p)  //这里默认s大于p？这个gcd写得比我的简洁多了……
{
  return p>0?gcd(p, s%p):s;
}
*/
void prints(int s, int p, bool choice)
{
	printf("%10d%10d    %s\n\n", s, p, choice?"Good Choice":"Bad Choice");
}



int  main()
{
	int step, mod;
	while (scanf_s("%d%d", &step, &mod) != EOF)
	{
		if (step == 0 || mod == 0)
		{
			prints(step, mod, false);
			continue;
		}
			
		prints(step, mod, gcd(step, mod));
	}
	return 0;
}

```

#### 另一个新的思路！

直接暴力遍历。判断两次出现同样值的时候，周期是否为mod。我认为这个想法很妙，比线性同余的办法要妙。

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;

int main()
{
    int step, mod;
    while (scanf("%d%d", &step, &mod) != EOF)
    {
        int d = 0;
        int i = 1;
        for ( ; d = (d+step)%mod; i++)
            ;
        printf("%10d%10d    %s\n\n", step, mod, i == mod ? "Good Choice" : "Bad Choice");
    }
    return 0;
}
```





