---
title: 1003
description: HDU OJ 1003
categories:
- HDU
tags:
- HDU
---

### HDU OJ 1003

题目：求解一串序列中的最大连续子序列和。

例：序列{6,-1,5,4,-7}， 其最大连续子序列和为 6+(-1)+5+4 = 14。由连续子序列{6，-1，5，4}产生。



实话实说，我没有看明白这个问题背后真正的意义在哪里。

特点：序列的起始和结束一定是正数。

----

2018-8-10：恕我直言，走在路上也没有想到这个问题的应用场景。不过倒是想了一个方法。

私以为连续子序列是这个问题的关键所在。相当于在这一串序列和中找到最大的和。于是做了一个递加序列。从数据的第1个开始，一直加和加到最后一个数据。

然后从中找到最大的和，减去前面所产生的最小负数序列就是得到的最终结果。示例如下

|----- MIN(<0,否则就是起始位置) **——————**MAX--------------|

从MIN-MAX之间的就是所求序列，而最终输出为MAX+（-MIN）。

如果min为正数，则子序列的起始位置为整个序列的起始位置。

下面是代码:

_比较让我费解的是，我只是换了一个写法，然后就是wrong answer了。神奇的世界_

```c++
#include <cstdio>
#define INF 0x3F3F3F3F

int main()
{
	int T;
	int n;
	int Case = 1;
	int num[100000 + 5];
	scanf("%d", &T);
	while (T--)
	{
		scanf("%d", &n);
		for (int i = 1; i <= n; i++)
			scanf("%d", &num[i]);
		int sum = 0;
		int ans = -INF;
		int tst = 1;		//临时存放起点
		int endd = tst;     //存放末点 
		int st = 1;         //真正的起点 
		for (int i = 1; i <= n; i++)
		{
			sum += num[i];
			if (sum > ans)
			{
				ans = sum;
				st = tst;
				endd = i;
			}
			if (sum < 0)
			{
				sum = 0;
				tst = i + 1;
			}
		}
		printf("Case %d:\n", Case++);
		printf("%d %d %d\n", ans, st, endd);
		if (T != 0)
			printf("\n");
	}
	return 0;
}

```

总之算是思考了一个问题吧！

谈不上什么算法= =

{{page.date | date_to_string }}

