---
title: 1007
description: HDU OJ 1007
categories:
- HDU
tags:
- HDU
---

### HDU OJ 1007 -- Quoit Design

1007是图论的题目。图上有N个点，求任意两点间的最短距离。所求半径则是最短距离的一半啦。

如果穷尽求解，那么N个点的复杂度为 O(N!)。随着N的增加（题目中Nmax = 100000）求解复杂度也会爆炸上升。

方案1：直接计算 -- Time Limit Exceeded

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <vector>
using namespace std;

using std::vector;
using std::pair;

int main()
{
	int n;
	while (scanf_s("%d", &n) != EOF)
	{
		if (n == 0) break;
		vector<pair<float, float> > points;
		
		float mins = INT_MAX;
		while (n--)
		{
			float x, y;
			cin >> x >> y;
			points.push_back( std::make_pair(x, y));
		}

		vector<pair<float, float>>::iterator  oneit = points.begin();
		vector<pair<float, float>>::iterator  twoit;
		vector<pair<float, float>>::iterator  endit = points.end();
		for (; oneit != endit - 1; oneit++)
		{
			for (twoit = oneit + 1; twoit != endit; twoit++)
			{
				float tmp = sqrt(pow((oneit->first - twoit->first), 2) + pow((oneit->second - twoit->second), 2));
				if (tmp < mins)
					mins = tmp;
			}
		}
		
		printf("%.2f\n", mins/2.0);
	}
    return 0;
}
```

方案2：学习来的分治法。

就是【大事化小，小事化无】的思想，同时结合剪枝的操作。

将所有的点按x坐标排序（y坐标同理），然后将点集合一分为二。

那么问题就变成了 _**求左边点集合的最小半径**_  和 **_求右边点集合的最小半径_** 以及 **_中间点所产生的可能的最小半径_** 。 ——分而治之。

而中间点可能产生的最小半径只有在 **_小于左右所产生的最小半径_** 的前提下才可能是最终解。——剪枝。

至于分治的办法到底为什么提升了效率，**大约**是因为求小集合的速度要快于求大集合最小半径的解吧。同时还有剪枝操作，避免了不必要的一些计算。【这个地方我没来得及实际求证】

而同样的理论上，用c++容器 vector和pair求解过程中，引发了 stack overflow的错误。但是将vector用普通结构体数组、 pair由简单结构体替代的时候却没有问题。 很无奈。

最后一如既往的——AC代码

```c++
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
using namespace std;

#define INF 0x3f3f3f3f
#define maxn 100010
struct node
{
	double x, y;
};
node p[maxn], t[maxn];
int cmpxy(node a, node b)//将点按横坐标升序排,横坐标相同按纵坐标升序排 
{
	if (a.x == b.x)
		return a.y<b.y;
	return a.x<b.x;
}

int cmpy(node a, node b)//将点按纵坐标升序排 
{
	return a.y<b.y;
}

double dis(node a, node b)//求两点间距离 
{
	return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));
}

double closest(int left, int right)
{
	double d = INF;		 
	if (left == right)	//集合中只有一个点时返回d值 
		return d;
	if (left + 1 == right)	//集合中只有两个点的时候返回这两点间距离 
		return dis(p[left], p[right]);
	int mid = (left + right) / 2;//分治 
	double d1 = closest(left, mid);
	double d2 = closest(mid + 1, right);
	d = min(d1, d2);
	int k = 0;
	for (int i = left; i <= right; i++)//将mid附近一个可能出现最短距离的范围中的点拿出来另作讨论 
		if (fabs(p[i].x - p[mid].x) <= d)
			t[k++] = p[i];
	sort(t, t + k, cmpy);			//将这些点按纵坐标升序排 
	for (int i = 0; i<k; i++)//枚举这些点间的距离来更新d 
		for (int j = i + 1; j<k&&t[j].y - t[i].y<d; j++)//当两点间纵坐标距离已经超过d则可以直接进入下一次循环 
			d = min(d, dis(t[i], t[j]));
	return d;
}
int main()
{
	int n;
	while (scanf_s("%d", &n) == 1 && n)
	{
		for (int i = 0; i<n; i++)
			scanf_s("%lf%lf", &p[i].x, &p[i].y);
		sort(p, p + n, cmpxy); 
		printf("%.2lf\n", closest(0, n - 1) / 2); 
	}
	return 0;
}
```



{{page.date | date_to_string}}

